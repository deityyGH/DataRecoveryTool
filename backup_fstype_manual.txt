inline bool DriveHandler::isFat32(const uint8_t* buffer) {
    return std::memcmp(buffer + FAT32_IDENTIFIER_OFFSET, "FAT32", 5) == 0;
}
inline bool DriveHandler::isExFat(const uint8_t* buffer) {
    return std::memcmp(buffer + EXFAT_IDENTIFIER_OFFSET, "EXFAT", 5) == 0;
}
inline bool DriveHandler::isNtfs(const uint8_t* buffer) {
    return std::memcmp(buffer + NTFS_IDENTIFIER_OFFSET, "NTFS", 4) == 0;
}
// Physical
inline bool DriveHandler::isFat32Guid(const uint8_t* buffer) {

}
// Detect filesystem from GPT partition GUID
FilesystemType DriveHandler::getFSTypeFromGPTPartition(const uint8_t partitionTypeGUID[16]) {
    if (std::memcmp(partitionTypeGUID, GUID_FAT32_TYPE, 16) == 0) {
        return FilesystemType::FAT32_TYPE;
    }
    return FilesystemType::UNKNOWN_TYPE;
}

FilesystemType DriveHandler::getFilesystemType() {

    if (this->driveType == DriveType::LOGICAL_TYPE) {
        uint8_t* buffer = new uint8_t[bytesPerSector];
        readSector(0, buffer, bytesPerSector);
        if (isFat32(buffer)) return FilesystemType::FAT32_TYPE;
        else if (isExFat(buffer)) return FilesystemType::EXFAT_TYPE;
        else if (isNtfs(buffer)) return FilesystemType::NTFS_TYPE;
    }
    else if (this->driveType == DriveType::PHYSICAL_TYPE) {
        throw std::runtime_error("Physical Drive is not implemented yet.");
        /*readSector(1, &gpt, 512);
        printGPTHeader();*/
    }
    return FilesystemType::UNKNOWN_TYPE;
}

FilesystemType DriveHandler::getFSTypeFromMBRPartition(uint8_t type) {
    return static_cast<FilesystemType>(type);
}

/*=============== Partition type identification ===============*/
bool DriveHandler::isGpt(const uint8_t* buffer) {
    return std::memcmp(buffer + GPT_SIGNATURE_OFFSET, "EFI PART", 8) == 0;
}
bool DriveHandler::isMbr(const uint8_t* buffer) {
    return buffer[MBR_SIGNATURE_OFFSET] == 0x55 && buffer[MBR_SIGNATURE_OFFSET + 1] == 0xAA;
}
